# 1주차 과제

# 브라우저의 동작 방법

- 브라우저 주요 기능
    - 브라우저는 사용자가 선택한 자원을 서버에 요청하는데 이 자원의 주소가 바로 url 이다.
    - 브라우저의 사용자 인터페이스는 서로 닮아 있다.
        - 주소 표시줄
        - 이전, 다음 버튼
        - 북마크
        - 새로 고침 버튼 문서 로드 정지 버튼
        - 홈 버튼
    - 
    
- 브라우저의 기본 구조
    1. 사용자 인터페이스 : 주소 표시줄, 이전/ 다음 버튼, 등 요청한 페이지를 제외한 모든 부분
    2. 브라우저 엔진 : 사용자 인터페이스와 랜더링 앤진 사이의 동작을 제어
    3. 렌더링 엔진 : 요청한 콘텐츠 표시.(역할 : 요청받은 내용을 브라우저에 표시)
        1. 렌더링 엔진 종류 : 게코 엔진, 웹킨 엔진 크게 두가지
        웹킷과 게코엔진의 동작과정은 기본적으로 동일함
        2. 동작과정 : 
        dom 트리 구축 위한 HTML 파싱 → 렌더 트리 구축 →렌더 트리 배치 → 랜더 트리 그리기
        3. 랜더 트리: 시각적 속성이 있는 사각형을 포함 정해진 순서대로 화면에 표시
    4. 통신 : http 요청과 같은 네트워크 호출에 사용
    5. UI 백엔드 : 콤보 박스와 창 같은 기본적인 장치를 그림. 운영체제의 사용자 인터페이스 체계를 제공함
    6. 자바스크립트 해석기 : 이름 그대로 js 해석
    7. 자료 저장소 : 쿠키를 저정하는 것 같이 데이터를 하드에 저장
  
    
    ![기본구조 모양]![image](https://github.com/user-attachments/assets/b94655ae-850c-4c92-9337-67b7c28262f5)
    
    기본구조 모양
    
- 파싱, DOM 트리 구축
    
    파싱의 정의 : 문서 파싱은 브라우저가 코드를 이해하고 사용할 수 있는 구조로 변환하는 것을 의미한다. 파싱 결과는 보통 문서 구조를 나타내는 노드 트리인데 파싱 트리(parse tree) 또는 문법 트리(syntax tree)라고 부른다.
    
    파싱 문법 : 파싱은 문서에 작성된 언어 또는 형식의 규칙에 따르는데 파싱할 수 있는 모든 형식은 정해진 용어와 구문 규칙에 따라야 한다. 이것을 [문맥 자유 문법]![image-2](https://github.com/user-attachments/assets/d64104d2-6e57-41b5-94ea-334dc9459faf)이라고 한다. 인간의 언어는 이런 모습과는 다르기 때문에 기계적으로 파싱이 불가능하다.
    
    파서 : 파서는 보통 두 가지 일을 하는데 자료를 유효한 토큰으로 분해하는 어휘 분석기(토큰 변환기 라고도 부름)가 있고 언어 구문 규칙에 따라 문서 구조를 분석함으로써 파싱 트리를 생성하는 파서가 있다. 어휘 분석기는 공백과 줄 바꿈 같은 의미 없는 문자를 제거한다.
    
    ![문서 소스로부터 파싱트리를 만드는 방법]![image-3](https://github.com/user-attachments/assets/e0eda74c-a182-458b-872c-a973e203e97a)
    
    문서 소스로부터 파싱트리를 만드는 방법
    
    규칙에 맞지 않으면 파서는 토큰을 내부적으로 저장하고 토큰과 일치하는 규칙이 발견될 때까지 요청한다. 맞는 규칙이 없는 경우 예외로 처리하는데 이것은 문서가 유효하지 않고 구문 오류를 포함하고 있다는 의미다.
    
    이렇게 생성된 파싱트리가 최종 결과물이 아니고 파싱은 보통 문서를 다른 양식으로 변환하는데 컴파일이 하나의 예시가 된다. 컴파일러가 소스코드를 기계코드로 변환함 
    
    ## 파싱의 예시
    
    어휘는 보통 정규 표현식 으로 표현된다.
    
    문법이 문맥 자유 문법일 경우 언어는 정규 파서로 파싱할 수 있다.
    이 때 많은 프로그래밍 언어 문법은 문맥 자유 문법에 속하고 이러한 문법은 컴파일러와 같은 이론에 중요한 역할을 차지한다
    
    ## 파서의 종류
    
    상향식 파서 : 루트 노드 에서 부터 리프 노드 들을 생성해가는 방식
    
    하향식 파서 : 리프 노드 에서 부터 루트 노드 쪽으로 위로 생성해가는 방식
    
    ## 파싱 알고리즘
    
    기본적으로 위 사진과 같은 형태를 띈다 
    
    문자를 만나면 “태그 열림 상태” 로 변하고 이 경우 HTML 토큰을 생성함 
    
    ![HTML의 파싱 과정]![image-3](https://github.com/user-attachments/assets/e0eda74c-a182-458b-872c-a973e203e97a)
    
    HTML의 파싱 과정
    
- HTML 의 경우
    
    HTML 파서의 경우는 마크업을 파싱 트리로 변환한다.
    
    HTML 은 문맥 자유 문법이 아니라서 전통적인 파서는 HTML에 적용할 수 없다. 그럼에도 불구하고 파싱을 사용하는 이유는 CSS , JS 를 파싱하는데 사용하기 때문이다.
    
    HTML은 파싱하기 어렵고 전통적인 구문 분석이 불가능하기 때문에 문맥 자유 문법이 아니라는 것이다. XML 파서로도 파싱하기 쉽지 않다. 
    
    HTML태그를 DOM 트리로 변환 할 때  문서 요소를 기준으로 최 상단에 위치하면서 내려가는 구조임 가장 크게 포함하는게 가장 최상단으로 온다고 보면 됨
    
    HTML 이 파싱될 때 오류가 있다면 파서는 다음과 같은 경우로 나누고 파싱을 처리한다
    
    1. *어떤 태그의 안쪽에 추가하려는 태그가 금지된 것일 때 일단 허용된 태그를 먼저 닫고 금지된 태그는 외부에 추가한다.*
    2. *파서가 직접 요소를 추가해서는 안된다. 문서 제작자에 의해 뒤늦게 요소가 추가될 수 있고 생략 가능한 경우도 있다. HTML, HEAD, BODY, TBODY, TR, TD, LI 태그가 이런 경우에 해당한다.*
    3. *인라인 요소 안쪽에 블록 요소가 있는 경우 부모 블록 요소를 만날 때까지 모든 인라인 태그를 닫는다.*
    4. *이런 방법이 도움이 되지 않으면 태그를 추가하거나 무시할 수 있는 상태가 될 때까지 요소를 닫는다.*
    
    이러한 절차를 통하여 오류를 해결한 사례는 다음과 같다.
    
    ```html
    <table>
    
        <table>
    
        <tr><td>inner table</td></tr>
    
        </table>
    
        <tr><td>outer table</td></tr>
    
    </table>  
    ```
    
    ```html
    <table>
    
        <tr><td>outer table</td></tr>
    
    </table>
    
    <table>
    
        <tr><td>inner table</td></tr>
    
    </table>  
    ```
    
- CSS 의 경우
    
    ## CSS 파싱
    
    CSS 파서는   스타일 시트를 루트 노드로 시작하여 상향식 으로 파싱된다. 나눠지는건 다음 사진과 같은 모양으로 나눠진다.
    
    ![신기한거는 선택자, 선언이 나뉜다는게 신기하다]![image-4](https://github.com/user-attachments/assets/2628bbc4-6701-4083-8816-2da5391f5a2a)
    
    신기한거는 선택자, 선언이 나뉜다는게 신기하다
    
    노드가 형제이거나 사촌일 경우 
    
- CSSOM
    
    HTML은 링크 태그를 만나는 순간 HTML 파일을 가져온 IP 주소로 CSS 파일을 가져오기 위해서 다시 요청을 함 요청을 하면 HTML 돔트리와 같은 형식으로 데이터를 가져온다 CSSOM 은 상위 요소가 하위요소들로 뻗어나가는 모양으로 나오고 추가적으로 추가한 스타일을 CSSOM에 적어주는? 느낌이다
    스타일 시트는 돔트리를 변경하지 않기 때문에 문서 파싱을 기다리거나 중단할 이유가 없다 그러나 다른 문서를 파싱하는 중 스타일 시트를 요청하면 문제가 생긴다 
    
- DOM 트리와 랜더 트리의 관계
    
    렌더러는 DOM 요소에 부합하지만 1:1로 대응하는 관계는 아니다. DOM 요소에 여러가지  CSS속성이 올 수 있다는 것 + display 속성에 “none” 값이 할당된 요소는 트리에 나타나지 않는다 하지만 “hidden”은 나타난다.
    

구조체에서 어떤 선언도 발견할 수 없는 경우 구조체는 "상속(inherit)" 타입

버츄얼 돔은 실제 돔 보다 가벼운 버전이라고 생각하면됨

WHY? : 클래스나 스타일 같은 속성은 가지고 있지만 api ,매서드는 가지고 있지 않기 때문임 

그렇기 때문에 화면에 있는 문서에 직접적으로 영향을 끼칠 수 없음

기존의 DOM 요소를 조작할 경우 

예시로 CSS를 변경할 때 잔여된 스타일을 제거하고 새롭게 작성된 스타일을 추가하여 화면에 다시 그려주는 개념인데 이를 매번 변경할 경우 같은 리스트 이내에서 각자 처리하기 때문에 같은 작업을 여러번 반복해야하는 비효율적인 상황이 나타날 수 있음 

여기서 리액트의 장점을 알 수 있음

앞서 말한 방식과 다르게 변경된 dom모델들을 객체로 가상화 하여 화면을 그리는 과정을 따로 반복하지않고 변경된 내용들을 한번에 받아온 다음 한번에 화면에 그려줌

SPA - CSR : 서버 부하가 적고 화면 깜빡임이 적다 하지만 초기 로딩이 느리다

MPA - SSR : 초기 로딩이 빠르다 하지만 화면이 깜빡일 수 있고 서버 부하가 있다

하나의 페이지로 구성된 어플리케이션을 뜻함
