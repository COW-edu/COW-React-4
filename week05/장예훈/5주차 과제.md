# 5주차 과제

# Hook

의의 : 함수 컴포넌트 에서 클래스 컴포넌트와 비슷한 기능을 사용하기 위해 개발된 기술이 hook 이라는 기능이다. ex) 컴포넌트 생명주기 함수 사용 등

대표적인 예시 : useState(), useEffect()

사용법은 const [fuc,setFuc] = useState(0); 이러한 모양으로 사용됨 

훅의 규칙 : Hook은 무조껀 최상위 레벨(리액트 함수 컴포넌트 에서 최상위 레벨)에서만 호출해야함

## 스테이트의 생명주기

### 출생(마운트) : 생성자가 실행 → 컴포넌트의 스테이트 정의 → 컴포넌트 렌더링 → 컴포넌트 마운트 호출

### 업데이트 과정 : props 변경, setState()로 스테이트 변경, forceUpdate()강제업데이트로 인해 다시 렌더링

### 사망(언마운트) : 상위에서 하위 컴포넌트를 더이상 호출 하지 않을 때  사망한다고 함

**의의 : 컴포넌트가 계속 존재하는게 아닌 시간의 흐름에 따라 생성되고 업데이트 되다가 사라짐 이게 리액트 생명주기의 의미임**

생성자 에서는 앞으로 사용할 데이터를 스테이트에 집어넣어 초기화한다 

componentDidMount() 생명주기 함수를 사용해 이 생명주기가 감싸고 있는 함수는  reservedNotifications 이 배열에 있는 메세지를 notifications 이 배열에 넣어주는 역할을 함 이러한 과정에서 setState를 사용하여 업데이트함

# UseState

정의: 훅의 등장과 함께 함수 컴포넌트 에서 스테이트를 사용하기 위해 만들어진 훅의 일종이다.

useState는 함수 컴포넌트 안에서 this.state 를 사용할 수 없기 때문에 만들어진 함수이다 결론적으로는 useState 또한 JS함수이고 함수인 특징을 가지기 때문에 인자 값도 받고 다른 값을 리턴 하기도 한다

특징:  배열의 형태로 저장되고 첫번째 요소는 최초의 렌더링 중 전달한 요소 두 번째는 state를 다른 값으로 업데이트 및 리렌더링 하는 set함수 

매개변수

nextState의 정의는 상태가 업데이트 된 이후의 컴포넌트의 새로운 값을 말한다 

공식문서 :  이 함수는 순수해야 하고, 대기 중인 state를 유일한 인수로 사용해야 하며, 다음 state를 반환해야 합니다. React는 업데이터 함수를 대기열에 넣고 컴포넌트를 리렌더링 합니다. 

공식문서에서는 이렇게 서술하였다. 작성자는 setState함수는 state의 값을 변환할 때 인자로 입력받은 값을 변형해서 변경하는것이 아닌 인자로 받은 값을 그대로 사용하여 state에 저장해야한다고 이해해였다.

사용법: 

```jsx
import { useEffect, useState } from 'react';

const [count,setCount] = useState(initialValue);

return (
  <div>
    <p> count: {count} </p>
    <button onClick={() => setCount(count + 1)}>증가</button>
  </div>
 );
}     
```

**useState를  사용할 때** setCount**를 이용하여 사용해야하는 이유**

상태 업데이트의 비동기성 때문이다.

상태 업데이트의 비동기성 이란? : 상태가 즉시 업데이트 되지않고 그 다음 렌더링에서 리액트가 상태를 업데이트 하는 걸 말한다.

set 함수는 반환값이 없다?

set함수는  렌더링에 대한 state변수만 업데이트 하기 때문에 set함수를 호출한 이후에도 state변수는 여전히 호출 전 화면 값이 담겨있다

주의사항

주의사항으로는 만약 변경한 새로운 값들이 현재state와 동일하다고 판단된다면 리액트는 컴포넌트와 그 자식 컴포넌트들을 리렌더링 하지 않는다. 

이미 진행중인 코드에서 같은 값의 코드는 실행되지않는다. 이러한 경우 업데이터 함수를 사용해 해결할 수 있다

```jsx
function handleClick() {
  setAge(age + 1); // setAge(42 + 1)
  setAge(age + 1); // setAge(42 + 1)
  setAge(age + 1); // setAge(42 + 1)
} //이런 경우 결론적으로 나이는 1만 추가됨

function handleClick() {
  setAge(a => a + 1); // setAge(42 => 43)
  setAge(a => a + 1); // setAge(43 => 44)
  setAge(a => a + 1); // setAge(44 => 45)
}
//이렇게 사용해아 한번의 클릭을 3번 추가가 가능함
```

객체, 배열을 state에 업데이트 가능하다 하지만 state는 리액트에서 읽기 전용 이므로 기존의 객체의 값을 변경하는게  set함수를 사용하여 전반적으로 교체하는 방식으로 업데이트를 해야한다 

궁금했던점 : const는 상수상태라 변하면 안되는건데 왜 setCount를 사용하면 값이 왜 변경되는건지, 셋카운트 라는 함수역할을 해서 이런 현상이 발생하는건지 궁금합니다.

# UseEffect,사이드 이펙트

리액트에서 말하는 사이드 이펙트는 효과, 영향 이라는 의미에 가깝다. 유즈 이펙트 훅 하나로 생명주기 함수와 동일한 기능을 이용할 수 있다.

useEffect 의 실행시기 : 컴포넌트가 처음으로 렌더링 될 때 혹은 업데이트로 인한 재렌더링 이후 

사용방법 : useEffect(이펙트 함수, 의존성 배열);

의존성 배열? : 배열안에 있는 값이 하나라도 변경 됐을 때 useEffect() 함수를 호출 

만약 의존성 배열 자리에 [] 빈 배열을 넣게 된다면 여러번 실행되지않음 추가적으로 의존성 배열을 생략이 가능한대 생략하게된다면 업데이트 될 때 마다 호출함

```jsx

useEffect(() => {
//컴포넌트가 마운트 된 이후,
//의존성 배열에 있는 변수 중 하나라도 값이 변경된 경우 실행
//의존성 배열에 빈 배열값을 넣는다면 컴포넌트의 변경이 생길 때 마다 변경됨
//배열을 생략한다면 컴포넌트가 업데이트 될 때 마다 위 힘수를 호출함
return () => {
	//컴포넌트가 마운트 해제되기 전에 실행됨
}
, 의존성 배열)}

```