# 2주차 과제

# JSX

### JSX의 개념

- **기본적으로는 HTML 태그를 변수로 할당, 호출, 리턴을 할 수 있게 도와주는 확장 문법이다.**
- 자바스크립트를 확장한 문법이다 하지만 공식적인 문법은 아니다
- 브라우저는 JSX를 자바스크립트 형태의 코드로 변환한다
- JSX는 **React “엘리먼트(element)”** 를 생성한다. React 엘리먼트는 브라우저 DOM 엘리먼트와 달리 일반 **객체**이다.

### JSX 문법

- JSX의 중괄호 안에는 자바스크립트의 모든 표현식이 들어올 수 있다 단 자바스크립트의 표현식을 사용할거면 {} 안에 사용해야함 또한 class의 경우 자바스크립트의 문법인 class 문법과 충돌할 가능성이 있기 때문에 class가 아닌 className을 사용함
- JSX는 변수에 저장하거나 함수의 인수로 넘길 수 있다.

```jsx
//jsx 의 형태
function App() {
	return (
      <h1>Hello world!</h1>
    );
}
//jsx를 자바스크립트는 이렇게 해석한다.
function App() {
	return React.createElement("h1", null, "Hello world!");
}
//jsx 와 html의 차이점

//html 태그
<div class="class1"> 'Hello world!' </div>
//JSX 태그
<div className="class1"> 'Hello world!' </div>
```

- 기존의 자바스크립트와 차이점으로 Event를 처리하는 방법이 있다
자바스크립트의 경우 이벤트리스너를 이용하여 직접적으로 DOM 요소에 접근하는 반면 JSX는 태그를 작성할 때 이벤트 핸들러 라는걸 부여함
- 아래 코드와 같이 JSX는 이벤트 앞에 ON을 붙혀서 camelCase로 작성하고 문자열이 아닌 함수로 이벤트 핸들러를 전달함

```jsx
//js
const name = document.querySelector('h1')
    name.addEventListener('click', nameClick);
//JSX
<h1 className="exampleName" OnClick={nameClick}> Hello World! </h1>
```

- 반드시 최상위에 감싸고 있는 태그가 하나 있어야한다
- 리액트는 최상위 태그가 특별한 의미나 스타일이 없을 때 불필요한 돔요소를 생성하게된다 이 때 <React.fragment> 를 통해서 불필요한 요소를 생성하지 않고 자식 태그들을 간단하게 그룹화 할 수 있다.

### JSX 장점

- HTML 과 유사하기 때문에 일반적인 JS로 작성된 코드보다는 가독성이 좋다.
- 활용도가 높음(div, span 태그와 같은 HTML 태그를 사용할 수 있어서)

### JSX 단점

- 리액트로 개발을 할 때 HTML, CSS, JS 코드를 작성하기도 하지만 상당부분을 JSX로 코드를 작성해야한다. 하지만 JSX는 공식적인 JS문법이 아니기 때문에 브라우저는 JSX를 이해하지 못한다. 때문에 리액트로 개발을 할 때는 JSX를 브라우저가 이해할 수 있는 평범한 자바스크립트로 변환시킬 방법이 필요하다.

## JSX를 알아보며 추가적으로 찾아본 정보

바벨 : 최신의 기능을 이전세대의 코드로 호환될 수 있도록 도와주는 역할을 한다 그 중 하나가 jsx이다 

이러한 바벨의 탄생 배경은 웹 브라우저 마다 지원하는 자바스크립트의 버전이 다르기 때문에 탄생함

# STATE

State의 개념

리액트 컴포넌트의 변경이 가능한 데이터로 쉽게 생각하면 자바스크립트의 변수 = 리액트의 State 라고 생각하면 쉽다

데이터의 흐름에 사용되는 것만 State에 사용해야한다. 왜냐하면 State가 변동되면서  컴포넌트가 다시 렌더링 되기 때문에

State는 하나의 객체이고 컴포넌트 내부에서 사용된다.

- STATE는 객체를 포함하여 자바스크립트의 모든 종류의 값을 가질 수 있다 하지만 React State 가 가진 값은 바꾸면 안됨 이런 부분이 자바스크립트의 변수와는 다른 부분이다.
- State를 바꿀거면 setState 와 같은 함수를 이용하여 변경해야함 
왜냐하면 리액트는 기본적으로 변화를 감지하여 새롭게 렌더링 해주는 라이브러리 인데 State를 직접 변경하면 변화를 감지못하기 때문이다.

```jsx
//setState 를 사용할경우
this.setState({ count: this.state.count + 1 });

//setState 를 사용하지 않을경우
this.State({ count: this.state.count + 1 });

```

위 코드의 경우 setState를 사용해서 화면에 렌더링이 되지만 State를 직접적으로 변경할 경우 화면에 렌더링이 안될 수 있다  왜냐하면 State는 특정 시점의 화면을 나타내기 때문에 직접적으로 수정을 할 경우 변화를 감지못하여 리액트는 렌더링을 안할 수 있기 때문이다.

State는 함수가 끝나기 전까지 기다렸다가 변경되는 모든 ui를 그려준다 왜냐하면 ui를 변경하고 그려주는 작업은 비싼 작업이기 때문이다 그렇기 때문에 화면은 업데이트 됐더라도 콘솔로그는 한 박자 느릴 수 있다

리액트의 함수 내부에서 State 값이 setState 라는 함수를 통하여 값이 업데이트 됐을 때 State값은 기억을 하고 있어도 일반적인 변수는 기억을 하지못해 초기화된다

# Props

정의 및 개념 : JSX태그에 전달하는 정보를 뜻함

- 상위 컴포넌트가 하위 컴포넌트에 값을 전달할 때 사용함
- 프로퍼티는 읽기전용이라 수정이 불가능하다
- 쉽게 생각하면 리액트가 속성을 부르는 방법 이라고 생각하면 된다

사용방법 : 문자열을 전달

할때는 “” 를 사용하고 그 외는 {} 를 사용한다.

```jsx
//props 예시코드
	<usedCar name = 'bwm' mileage = 100000 color = 'white'>
function usedCar(props){
 return (
	<div>
		<h2>{props.name}</h2>
		<p>주행거리: {props.mileage}</p>
		<p>color: {props.color}</p>		
	</div>
	);
}
```

이렇게 작성했을 경우 여러가지 정보를 쉽게 가져올 수 있다 

또한 여러가지 데이터를 한번에 컴포넌트로 전달하기 위해서 객체형태로 전달한다 왜냐하면 객체는 여러가지 정보를 묶어서 다룰 수 있기 때문이다

궁금했던거

- 반드시 최상위에 감싸고 있는 태그가 하나 있어야한다 이 부분이 이해가 잘 안갔음

해결: 최상위에 감싸고 있는 태그의 예시를 보며 이것은 부모 태그를 말하고 그 안에 있는 자식 태그들만 사용되면 안된다는걸 예시 코드를 보면서 이해했다 부모태그가 없이 자식 태그들만 있을 경우 가상돔 구조가 여러가지로 나누어 지고 이를 확인하면서 성능저하를 유발할 수 있기 때문이다 이를 방지하기 위하여 하나의 부모 태그 즉 최상위 태그가 하나 있어야 한다는 뜻이다.

- STATE는 객체를 포함하여 자바스크립트의 모든 종류의 값을 가질 수 있다 하지만 React State 가 가진 값은 바꾸면 안됨

이유 : 리액트는 비동기적으로 동작하기 때문에 state객체를 직접적으로 수정하여 실행하면 랜더링 업데이트가 안된 상태로 실행될 수 있음 추가적으로 성능향상을 위해여 호출을 해서 변화를 감지해 화면에 렌더링 하기 때문이다.

해결방안 : 함수형 업데이트를 사용 또는 useEffect 사용

- 왜 Props에서 {} 를 사용하지 않으면 적용이 안될까

이유: 자바스크립트에서 {}는 표현식을 뜻하기 떄문이다