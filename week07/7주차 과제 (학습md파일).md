# 7주차 과제

# 동기와 비동기

동기 : 코드 처리를 처음에 시작한 코드를 마칠 때 까지 한가지의 코드만을 사용하는 방식이다 예시로 맛집에서 웨이팅 하는 것과 같은 역할을 한다고 보면 된다 → 이러한 방식으로 처리하기 때문에 나머지 작업들은 대기해야한다 → 비효율적이다.

비동기 :  동기와 다르게 여러가지 작업을 병렬적으로 처리한다 예시로 카페에서 진동벨을 나눠주거나 맥도날드에서 여러명의 주문을 받고 주문번호를 불러주는 방식 이라해고 이해했다 비동기 요청시 응답 후 콜백 함수를알려주고 해당 작업이 완료된다면 콜백 함수를 호출한다 이러한 특징 때문에 많은 콜백함수가 생길 수 있고 콜백지옥 이라는 현상이 발생할 수 있다. 

## 프로미스

자바스크립트 에서 비동기 처리를 위한 패턴으로 콜백함수를 사용하는데 이러한 방식을 사용하다보면 콜백지옥이라는 현상을 겪게된다.  이 콜백지옥이란 여러개의 콜백함수가 겹쳐서 가독성을 떨어트리고 여러가지 함수를 사용하기 때문에 어느 부분에서 에러가 생긴다면 대처하기가 어려움 때문에 이러한 현상을 방지하기 위한 패턴으로 프로미스 라는걸 도입했다.   프로미스는 콜백 함수 패턴이 가진 단점을 보완하면서 비동기 처리 시점을 가장 명확하게 한다는 장점이 있다.

프로미스는 생성자 함수를 통하여 인스턴스 한다 프로미스 생성자는 비동기작업을 할 인수를 resolve, reject함수로 전달받음

```jsx
// Promise 객체의 생성
const promise = new Promise((resolve, reject) => {
  // 비동기 작업을 수행한다.

  if (/* 비동기 작업 수행 성공 */) {
    resolve('result');
  }
  else { /* 비동기 작업 수행 실패 */
    reject('failure reason');
  }
});
```

- pending : 비동기 처리가 아직 수행되지 않은 상태
- fulfilled : 비동기 처리가 수행된 상태(성공)
- rejected : 비동기 처리가 수행된 상태 (실패)
- settled : 비동기 처리가 수행된 상태 (성공, 실패 모두)

### 프로미스 호출과정

프로미스를 사용하는 비동기 작업에서는 그러면 성공/ 실패 두가지로만 나뉘어짐

예시로 기존의 콜백 방식에서는 인자의 위치가 데이터를 가져오는데 성공/실패를 구분했다

하지만 프로미스에서는 인자의 위치가 아닌 resolve(성공)/reject(실패)로 구분한다.

### 프로미스 체이닝

비동기 함수의 처리 결과를 가지고 다른 비동기 작업을 해야 할 경우 함수가 중첩되어 콜백지옥 현상이 발생하는데 프로미스는 콜백과는 다르게 후속처리를 위한 메소드인 then, catch로 다른 프로미스들을 연결해 쓸 수 있다

**then**: then 메소드는 두 개의 콜백 함수를 인자로 전달 받아 첫 번째는 성공(fullfilled, resolve) 두 번째 함수는 실패(rejected, reject) 했을 때 호출된다 then메소드는 Promise를 반환한다

**catch** : 비동기 처리에서 발생한 에러, then에서 발생한 에러가 생겼을 때 호출됨 얘도 Promise를 반환함

### 프로미스의 에러 처리 방법

```jsx
//then 메서드의 인자로 받아 처리하는 방법
getData().then(
	todoSuccess,
	todoError
	);
//catch를 사용하는 방법
getData().then().cathc();
```

## 비동기 작업 **Async / Await**

**Async / Await 의의 :** 이 두 개는 자바스크립트의 비동기 처리 패턴 중 가장 최근에 나온 문법인데 기존의 비동기 처리 방식인 함수와 프로미스의 단점을 보완하고 어떻게 작업을 할지 알려주기 때문에 더욱 편하게 사용이 가능하다고 한다

```jsx
async function 함수명() {
  await 비동기_처리_메서드_명();
}
```

**async 개념** 

async 는 함수 앞에서 사용한다 이렇게 하면 함수는 항상 프로미스를 반환하게되는데 이 때 이행상태의 프로미스로 값을 감싼다면 프로미스가 아닌 값을 반환하더라도 프로미스로 반환하게 된다.

 async가 붙은 함수는 반드시 프로미스를 반환하고, 프로미스가 아닌 것은 프로미스로 감싸서 프로미스로 반환한다.

async 얘는 화살표 함수로 정의가 가능하고 함수 표현식으로 정의도 가능함

### await

await은 async 함수 내부에서만 동작이 가능함 자바스크립트 에서는 await을 만나면 프로미스가 처리 될 때 까지 기다리고 결과는 그 이후에 반환한다

await을 사용했을 때 프로미스가 처리되기를 기다리는 과정에서 엔진이 다른 작업을 할 수 있기 때문에 cpu 리소스 낭비가 없다는 장점이 있다

**Async / Await 의 한계, 보완**

결국 문법적인 제약으로 인하여 Async와 Await은 함수 밖의 최상위 레벨 코드에서는 사용이 불가능하다(전역사용 불가) 이러한 현상은 앞서 학습한 .then / .catch 메서드를 통하여 보완이 가능하고 최상단에서 전역으로 사용하는 경우가 아니면 async / await을 사용하는게 더 편리하다

### **Async / Await** 예외를 처리하는 방법

예외의 상황을 처리하는 방법으로 try…catch구문이 있는데  try블록과 catch 블록 finally 블록 중 하나, 두 가지로 구성되는데 

만약 try코드 블럭이 먼저 실행되고 그 안에서 예외가 발생하면 catch의 코드블럭이 실행된다 finally는 항상 실행되고 제어 흐름이 전체 구문을 종료하기 전에 실행된다

```jsx
try {
  tryStatements
} catch (exceptionVar) {
  catchStatements
} finally {
  finallyStatements
}
```

## 에러 처리 방법

fetch, axios는 모두 이행되거나 거부되는 프로미스를 반환하는데 이 때 프로미스가 거부 당했을 때 .catch()함수를 사용해서 에러를 처리할 수 있음. 

```jsx
const url = "https://jsonplaceholder.typicode.com/todos";

axios
  .get(url)
  .then((response) => console.log(response.data))
  .catch((err) => {
    console.log(err.message);
  });
```

## AXIOS

Fetch 의 경우 두가지의 인자를 받는데 이 중 하나는 가져오고자 하는 리소스의 url, 두 번째 인자는 내가 전달하기 원하는 객체형 데이터 만약 두 번째 인자를 설정하지 않는다면 기본적으로 get 요청을 수행함 이러한 문법은 Axios에서도 비슷하다.

```jsx
axios(url, {});
```

```jsx
axios(url, {
	methid: "get",
	headers: {},
	data: {},
});
```

JSON에서의 데이터 처리 

fetch()함수는 .then()메서드에서 처리된 프로미스를 반환한다 이 때 아직 우리가 사용해야하는 데이터가 아니기 때문에 다시 응답객체의.json()메서드를 반환함 즉 내가 사용하는 객체가 아닌 일반적인 fetch 요청은 두 개의 .then() 호출을 갖는다.

Axios를 사용하면 응답 데이터를 기본적으로 JSON 타입으로 사용할 수 있으나 응답 데이터는 언제든지 응답 객체의 data프로퍼티로 사용함 어떻게 사용하는 거냐면 

```jsx
obj.data //이런식으로 사용
```

만약 내가 fetch API를 사용한다면 JSON.stiringify()를 사용해서 객체를 문자열로 변환한 뒤 바디 태그에 할당해야하지만

axios의 경우 자동으로 데이터를 문자열로 변환해준다

## axios 파라미터 옵션

Method : 요청방식 (Get이 디폴트)

url : 서버 주소

headers : 요청 헤더

params : URL 파라미터 ( 내가 조회를 하고싶은 키값과 벨류가 일치할 경우 요청하는 url get 방식을 객체로 표현한 것)

responseType :  서버가 응답해주는 데이터의 타입 지정(arraybuffer, documetn, json, text, stream, blob)

# REST

REST 란? :  서버가 가지고 있는 리소스의 상태가 표현돼 있는 것 서버가 보내준 JSON은 데이터베이스에 저장되어있는 원본 데이터 리소스의 현재 상태를 표현한 것이다.

```jsx
HTTP/1.1 200 OK
Content-Length: 45
Content-Type: application/json

{
  id: 2,
  name: 'Evan',
  org: 'Viva Republica',
}
```

이 코드의 경우 2번 유저의 데이터를 받아온다 이러한 경우 /api/users/2 이런식의 엔드 포인트를 통해서 2번유저의 데이터 리소스를 받았다고 표현하는데 내가 이해한 방식은 /뒤에 있는 데이터는 하위 데이터 라고 이해했다.

서버는 데이터 리소스의 원본이 아닌 DB에 저장된 데이터 리소스를 표현한 것에 불과하고 결론적으로 데이터 원본이 아닌 읽기전용 파일을 전달한 것 이다 

```jsx
GET https://iamserver.com/api/users/2
Host: iamserver.com
Accept: application/json //이 코드에서 Accept 값이 사용자가 받기를 원하는 데이터의 형식을 나타냄
```

만약 서버 응답 헤더에 content-type 또는 리소스는 어떤 방식으로 표현된 상태인지 클라이언트에게 알려주고 클라이언트는 이정보를 읽은 후 각 컨텐츠 타입에 맞게 정보를 전달한다.

REST는 클라이언트와 서버가 데이터 리소스의 타입이나 각 원하는 언어에 맞게 정보를 전달할 수 있도록 표현 할 수 있게 도와준다.

RESTful API 란? REST 리소스가 표현된 상태만을 이야기하고 어떠한 “행위” 에 대하여 이야기하지 않는 단점을 보완하기 위하여 존재한다 

여기서 행위란 어떤 데이터의 소스를 생성, 삭제, 수정 하는 것을 의미한다 

RESTful API 는 REST API의 설계 규칙을 올바르게 지켜야 RSETful 하다고 말할 수 있다 

## REST API 설계 예시

1. **URI는 동사보다는 명사를, 대문자보다는 소문자를 사용하여야 한다.**
2. **마지막에 슬래시 (/)를 포함하지 않는다.**
    1. 지배계층에 영향을 줄 수 있기 때문
3. **언더바 대신 하이폰을 사용한다.**
4. **파일확장자는 URI에 포함하지 않는다.**
5. **행위를 포함하지 않는다.**

HTTP 메소드를 사용해 API가 수행하는 행위를 표현하도록 권고한다

상황에 맞지 않는 메소드를 사용한다면 어플리 케이션이 예상하지 못한 동작을 일으 킬 수 있다

**주로 사용하는 메서드**

| Method | 의미 |
| --- | --- |
| GET | 데이터를 가져온다 |
| PUT | 데이터 내용을 업데이트 |
| DELETE | 데이터를 삭제한다 |
| POST | 데이터를 처음에 준다 |
| PATCH | 리소스의 일부를 수정한다 |

PUT, PATCH의 차이 

put 메서드는 리소스 수정을 하는데 수정할 사항만 보내는 것이 아니라 수정하지 않을 사항까지 모두 보낸다 리소스를 대처한다는 특성 상 id값이 null값으로 변경돼 id를 잃게되는 경우가 생길 수 있다

patch 메소드는 put 메소드처럼 리소스를 대체하는 행위가 아니기 때문에 요청을 어떤 방식으로 사용하는지에 대한 제한이 딱히 없기 때문이다patch 요청은 명확하게 필드의 일부를 수정한다는 의미만을 가진다 

404에러 : api 문제