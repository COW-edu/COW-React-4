### 1. CSS 등장 배경

1991년 HTML (Hyper Text Markup Language)가 처음 등장했을 당시, CSS (Cascading Style Sheets)가 없었다. 웹 디자인에 대한 요구가 커지자 1996년 CSS가 발표되었다. 하지만 웹이 점점 복잡해지고 동적 기능 요구가 증가하면서 HTML과 CSS만으로는 화면의 모든 스타일을 제어할 수 없게 되었다. 이를 해결하기 위해 두가지의 스타일 구성 방식인 **CSS-in JS**와 **CSS-in CSS**가 등장하게 되었다.

#### 2. CSS-in CSS

##### CSS 모듈 (Module)

CSS 모듈은 CSS 스타일을 더 체계적으로 관리하기 위한 방법이다. 기본적으로 CSS는 전역 스코프(global scope)를 가지고 있어서, 여러 파일에서 같은 클래스 이름을 사용하면 충돌이 발생할 수 있다. 이를 해결하기 위해 CSS 모듈은 다음과 같은 방식으로 작동한다.

1. **모듈화** : CSS 모듈을 사용하면 CSS 파일이 각각 독립적인 모듈로 나뉘어 관리된다. 즉, 각 모듈은 서로 영향을 주지 않고 독립적으로 스타일을 정의할 수 있다.
2. **고유한 클래스 이름 생성** : CSS 클래스를 정의하면, CSS 모듈은 자동으로 고유한(class name) 이름을 생성한다. 예를 들어, `button`이라는 클래스를 정의하면 실제로는 `button__abc123`와 같은 형태로 변환된다. 이렇게 하면 같은 이름을 가진 클래스가 다른 모듈에서도 충돌하지 않게 된다.
3. **지역적 스코프** : 각 CSS 모듈은 해당 모듈 내에서만 유효한 스타일을 가진다. 즉, 다른 모듈에서 같은 이름의 클래스를 정의하더라도 서로 영향을 주지 않아서, 스타일 관리가 더 용이해진다.
4. **번들러 사용** : CSS 모듈을 사용할 때, 번들러(예: Webpack)라는 도구를 사용하여 모듈화된 CSS를 불러온다. 이 과정에서 사용자가 정의한 클래스 이름과 생성된 고유한 클래스 이름이 함께 포함된 객체가 반환된다. 이를 통해 JavaScript 코드에서 쉽게 사용할 수 있다.

##### CSS 전처리기 (Preprocessor)

자신만의 특별한 구문(Syntax)을 가지고 CSS를 생성하는 프로그램이다. 변수, 함수, 상속 등 일반적인 프로그래밍 개념을 사용하여 보완한다.

CSS 전처리기는 공통 요소를 변수 또는 함수로 대체할 수 있는 **재사용성**, 임의 함수 및 내장 함수로 인해 **개발 시간과 비용 절약**, 중첩·상속과 같은 요소로 인해 **구조화된 코드 유지** 및 **관리 용이** 등의 장점이 있다. 하지만 전처리기를 위한 도구가 필요하고 다시 컴파일하는데 시간이 소요된다는 단점도 존재한다.

###### 1. Sass

전처리기 중 가장 먼저나온 Sass는 초기에는 루비 (Ruby) 언어를 기반으로 구동되었는데, 컴파일 속도가 느려 그 다음에 나온 Less에게 추월당한다. 하지만 Node-Sass라는 Node.js 기반의 라이브러리가 나오면서 다시 인기를 얻고 있다.
Node-Sass는 Node.js 기반으로 작성되어있어, Ruby 기반의 Sass보다 컴파일 속도가 빠르고, Sass의 기능을 확장하는 다양한 플러그인과 도구를 지원하는 등, 개발자들이 필요로 하는 추가 기능을 쉽게 사용할 수 있다.

###### 2. Less

Less는 트위터의 부트스트랩 (Bootstrap)에 사용되면서 알려졌다. 브라우저에서 자바스크립트 문법을 취하고 있으며 Node.js 기반으로 구동된다.

###### 3. Stylus

프로그래밍 언어의 특징을 가진 것으로, 어 CSS 프로퍼티 내에서 연산자나 함수, 루프 등을 비교적 자유롭게 사용할 수 있다.

**결론적으로 CSS-in-CSS는 CSS를 작성할 때 사용하는 일반적인 방식 중 하나로, CSS 코드 내에서 직접 스타일을 정의하고 적용하는 방법이다.**

#### 3. CSS-in JS

CSS-in JS는 말 그대로 자바스크립트 코드에서 CSS를 작성하는 방식을 말한다. CSS를 작성하는 어려움을 CSS-in JS로 해결할 수 있다고 개발자가 이야기하였다.

1. Global namespace: 글로벌 공간에 선언된 이름의 명명 규칙 필요
2. Dependencies: CSS간의 의존 관계를 관리
3. Dead Code Elimination: 미사용 코드 검출
4. Minification: 클래스 이름의 최소화
5. Sharing Constants: JS와 CSS의 상태 공유
6. Non-deterministic Resolution: CSS 로드 우선 순위 이슈
7. Isolation: CSS와 JS의 상속에 따른 격리 필요 이슈

가장 대표적인 CSS-in JS 라이브러리인 Styled Components를 통해 별도의 라이브러리 설치에 따른 번들 크기 증대 및 CSS-in-CSS에 비해 느린 속도 등을 커버할 수 있는 예시를 보겠다.

```
title{
  font-size: 15px;
  color: white;
}
...
<h1 className="title">Hello World</h1>
```

위의 코드는 일반적인 CSS의 기본 작동 방식인데, Styled-Components의 기본 작동 방식의 예시 코드를 보겠다.

```

import styled from "styled-components";
...
const Title = styled.h1`
  font-size: 15px;
  color: white;
`;
...
<Title> Hello World</Title>
```

이렇게 Styled-Components를 사용하면 다음과 같은 장점이 있다.

1. **스타일과 컴포넌트의 결합**: 일반 CSS에서는 스타일과 HTML 구조가 분리되어 있지만, Styled-Components에서는 스타일을 컴포넌트와 함께 정의할 수 있기에 더 나은 응집성을 제공한다.
2. **코드 가독성**: 스타일을 컴포넌트와 함께 정의함으로써, 코드의 가독성이 높아지고, 관련된 코드가 근처에 위치하게 되어 유지보수가 용이하다.
3. **스코프 범위**: Styled-Components는 자동으로 스타일을 해당 컴포넌트에만 적용하기 때문에, 클래스 이름 충돌을 방지하며, 전역 CSS 문제를 해결할 수 있다.

#### 4. CSS-in JS vs CSS-in-CSS

그러면 어떤 때에 CSS-in JS가 개발에 용이하고, CSS-in-CSS가 개발에 용이할까?

##### * **컴포넌트 위주**

개발 효율성에 중점을 둔 컴포넌트 위주 프로젝트의 경우 `CSS-in-JS`를 지향한다.

즉, 필요한 컴포넌트 페이지의 CSS 스타일 요소만 로딩한다.

##### * **사용자 편의 위주**

사용자 편의에 중점을 둔 인터렉티브한 웹 프로젝트라면 렌더링 시 모든 CSS 스타일 요소를 로딩하는 CSS-in-CSS방식을 지향한다.

즉, 렌더링할 때 모든 CSS 스타일 요소를 로딩하기 때문에 컴포넌트 상대가 변하더라도 바로 적용이 가능하다.

---

### 1. Tailwind CSS란?

Tailwind CSS는 유틸리티 클래스를 사용하여 HTML에서 직접 스타일링을 할 수 있는 CSS 프레임워크이다. 즉, 부트스트랩과 비슷하게 m-1, flex와 같이 미리 세팅된 유틸리티 클래스를 활용하여 HTML 내에서 스타일링을 할 수 있는 것이 Tailwind CSS이다.

#### 2. Tailwind CSS의 장점

1. Utility-First 컨셉덕에 매우 쉽고 빠르게 원하는 디자인을 개발할 수 있으며, 스타일 코드도 별도의 CSS 파일에서 정의하는 대신, HTML 요소에 유틸리티 클래스를 직접 추가하여 빠르게 스타일을 조정할 수 있다.
2. 또한 랩핑 태그의 클래스명을 사용할 일이 거의 없으므로 container, wrappper, inner-wrapper와 같은 클래스명을 고민하지 않아도 된다.
3. 모든 곳에서 동일한 색상이나 사이즈, 간격 등의 유틸리티 클래스를 사용하므로 일관된 스타일로 구현하기가 수월하다.
4. Tailwind CSS는 다른 프레임워크들에 비해 기본 스타일 값을 디테일한 부분까지 쉽게 커스텀이 가능하다. 디자인 시스템이나 다크 모드 구현도 간편하다.
5. Tailwind CSS는 JavaScript 코드와 완전히 분리되어 있어 JavaScript 프레임워크를 변경하여도 큰 추가 작업 없이 기존의 HTML 코드를 그대로 쓸 수 있다.

##### 2-1. 나만의 질문: Utility-First 컨셉이란?

Utility-First 컨셉은 CSS 프레임워크에서 스타일을 구성하는 방식 중 하나로, 작은 유틸리티 클래스를 사용하여 요소의 스타일을 정의하는 접근법이다.

#### 3. Tailwind CSS의 단점

1.
```

<div
  class="bg-primary-darken text-bold text-white inline-flex items-center p-4 rounded shadow-md"
>
  Not Pretty Code 
</div>
```
위의 예시 코드같이 코드가 너무 길고 예쁘지 않다는 단점이 있다. (초보 개발자인 나의 눈으로 보아도 굉장히 코드를 볼 때, 복잡하다)
2. 각 스타일의 클래스명을 익히기 위해서는 개발하는 내내 문서를 참고해야하는 번거로움이 있다. 그래도 대부분의 클래스명이 기존 CSS 속성이나 속성값과 비슷한 경우가 많고 자동 완성을 지원하는 Intelli Sense 플러그인이 있긴하다.
3. 첫 번째의 단점과 비슷한데, HTML과 CSS의 코드가 헷갈리는 단점이 있다. Tailwind CSS의 단점을 꼽을 때, HTML과 CSS의 관심사 분리가 이루어지지 않았다고 언급되는 경우가 있다.
